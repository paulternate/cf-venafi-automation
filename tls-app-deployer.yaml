AWSTemplateFormatVersion: 2010-09-09
Description: https://hackathon2023-public.s3.amazonaws.com/2023-04/tls-app-deployer.yaml

# invoked as follows
# app_name=tls-app-deployer-$(date +%y%m%d%H%M)
# tlspksauserid=_
# tlspksausersecret='_' # <-- the quotes are necessary to suppress control chars
# tlspcapikey=_
# aws cloudformation create-stack \
#   --stack-name ${app_name} \
#   --template-url https://hackathon2023-public.s3.amazonaws.com/2023-04/tls-app-deployer.yaml \
#   --capabilities CAPABILITY_IAM \
#   --parameters \
#       ParameterKey='AppName',ParameterValue='"'${app_name}'"' \
#       ParameterKey='CAName',ParameterValue='BUILTIN' \
#       ParameterKey='ContainerImage',ParameterValue='amcginlay/test-container:1.0.0' \
#       ParameterKey='ContainerPort',ParameterValue='80' \
#       ParameterKey='TLSPKSAUserID',ParameterValue=${tlspksauserid} \
#       ParameterKey='TLSPKSAUserSecret',ParameterValue="'"${tlspksausersecret}"'" \
#       ParameterKey='TLSPCAPIKey',ParameterValue=${tlspcapikey} \
#       ParameterKey='TemplateName',ParameterValue='Built-In CA Template'

Parameters:
  LatestAmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2
  AppName:
    Type: String
    Description: Name used to identify the application
    Default: test-container
  ContainerImage:
    Type: String
    Description: OCI Image of application to be hosted on VM
    Default: amcginlay/test-container:1.0.0
  ContainerPort:
    Type: String
    Description: Internal port of the containerized app
    Default: 80
  TLSPKSAUserID:
    Type: String
    Description: e.g. discovery_demo0123456789@gallant-wright.platform.jetstack.io
  TLSPKSAUserSecret:
    Type: String
    Description: Matched secret for SA User ID
  TLSPCAPIKey:
    Type: String
    Description: From https://ui.venafi.cloud/platform-settings/user-preferences?key=api-keys
    NoEcho: true
  CAName:
    Type: String
    Description: The name of the Certificate Authority you want to use in TLS Protect Cloud
    Default: BUILTIN
  TemplateName:
    Type: String
    Description: The name of the Issuing Template you want to use in TLS Protect Cloud
    Default: Built-In CA Template

Resources:
  WebSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Allow HTTP(S) traffic
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0

  AppVM:
    Type: AWS::EC2::Instance
    # DependsOn: VenafiCustomResource <-------------- DON'T FORGET TO REPLACE THIS !!!!!!
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: m5.large
      IamInstanceProfile: AmazonSSMRoleForInstancesQuickSetup
      SecurityGroupIds:
        - !Ref WebSecurityGroup
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: 60
      Tags:
        - Key: Name
          Value: !Join ["-", [!Ref AppName, !Ref AWS::Region]]
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash

          export APP_NAME=${AppName}
          export CONTAINER_IMAGE=${ContainerImage}
          export CONTAINER_PORT=${ContainerPort}
          export TLSPK_SA_USER_ID=${TLSPKSAUserID}
          export TLSPK_SA_USER_SECRET='${TLSPKSAUserSecret}'
          export TLSPC_API_KEY=${TLSPCAPIKey}

          curl -sL https://hackathon2023-public.s3.amazonaws.com/2023-04/tls-app-deployer.sh | bash

          unset TLSPK_SA_USER_SECRET TLSPC_API_KEY

  # LambdaRole:
  #   Type: AWS::IAM::Role
  #   Properties:
  #     AssumeRolePolicyDocument:
  #       Version: '2012-10-17'
  #       Statement:
  #         - Effect: Allow
  #           Principal:
  #             Service: lambda.amazonaws.com
  #           Action: sts:AssumeRole
  #     ManagedPolicyArns:
  #       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # VenafiLambda:
  #   Type: AWS::Lambda::Function
  #   Properties:
  #     Runtime: python3.9
  #     Role: !GetAtt LambdaRole.Arn
  #     Handler: index.lambda_handler
  #     Timeout: 90
  #     Code:
  #       ZipFile: |
  #         import cfnresponse
  #         import json
  #         import os
  #         import random
  #         import urllib3
  #         import logging

  #         logger = logging.getLogger()
  #         logger.setLevel(logging.INFO)
  #         http = urllib3.PoolManager()

  #         def lambda_handler(event, context):
  #             logger.info('Received event: ' + str(event))

  #             api_key=(str(event['ResourceProperties']['TLSPCAPIKey']))
  #             application_name=(str(event['ResourceProperties']['AppName']))
  #             certificate_authority=(str(event['ResourceProperties']['CAName']))
  #             template_name=(str(event['ResourceProperties']['TemplateName']))

  #             if event.get('RequestType') == 'Create':

  #                 # get certificate authority id
  #                 response = http.request(
  #                     'GET',
  #                     f'https://api.venafi.cloud/v1/certificateauthorities/{certificate_authority}/accounts',
  #                     headers={
  #                         'accept': 'application/json',
  #                         'tppl-api-key': api_key
  #                     })

  #                 certificate_authority_id = json.loads(response.data.decode('utf-8'))['accounts'][0]['account']['id']

  #                 # get template id
  #                 response = http.request(
  #                     'GET',
  #                     f'https://api.venafi.cloud/v1/certificateissuingtemplates?certificateAuthorityAccountId={certificate_authority_id}',
  #                     headers={
  #                         'accept': 'application/json',
  #                         'tppl-api-key': api_key
  #                     })

  #                 template_id = next((t['id'] for t in json.loads(response.data.decode('utf-8'))['certificateIssuingTemplates'] if t['name'] == 'Default'), None)

  #                 # get the current user id
  #                 response = http.request(
  #                     'GET',
  #                     'https://api.venafi.cloud/v1/useraccounts',
  #                     headers={
  #                         'accept': 'application/json',
  #                         'tppl-api-key': api_key
  #                     })

  #                 user_id = json.loads(response.data.decode('utf-8'))['user']['id']

  #                 # create the application (FORWARD!)
  #                 print(f'Creating {application_name} in Venafi')
  #                 data = {
  #                     "name": application_name, 
  #                     "ownerIdsAndTypes": [ 
  #                         { 
  #                             "ownerId": user_id,
  #                             "ownerType": "USER"
  #                         }
  #                     ],
  #                     "certificateIssuingTemplateAliasIdMap": {
  #                         template_name: template_id
  #                     }
  #                 }

  #                 response = http.request(
  #                     'POST',
  #                     'https://api.venafi.cloud/outagedetection/v1/applications',
  #                     headers={
  #                         'accept': 'application/json',
  #                         'content-type': 'application/json',
  #                         'tppl-api-key': api_key
  #                     },
  #                     body=json.dumps(data).encode('utf-8')
  #                 )

  #                 app_guid = json.loads(response.data.decode('utf-8'))['applications'][0]['id']

  #                 responseData = {}
  #                 responseData['message'] = "Venafi application successfully created"
  #                 responseData['application_name'] = application_name
  #                 responseData['app_guid'] = app_guid
  #                 cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)

  #             elif event.get('RequestType') == 'Delete':
  #                 # get the application GUID - IS THIS NECESSARY or can we pull from output of 'Create' event?
  #                 response = http.request(
  #                 'GET',
  #                 f'https://api.venafi.cloud/outagedetection/v1/applications/name/{application_name}',
  #                 headers={
  #                     'accept': 'application/json',
  #                     'tppl-api-key': api_key
  #                 })
                  
  #                 # store response json data in a dictionary
                  
  #                 app_guid = json.loads(response.data.decode('utf-8'))['id']
  #                 print(f'App GUID: {app_guid}')

  #                 # delete the application (REVERSE!)
  #                 print(f'deleting {application_name}')
  #                 data = {
  #                     "name": application_name
  #                 }

  #                 response = http.request(
  #                     'DELETE',
  #                     f'https://api.venafi.cloud/outagedetection/v1/applications/{app_guid}',
  #                     headers={
  #                         'accept': 'application/json',
  #                         'content-type': 'application/json',
  #                         'tppl-api-key': api_key
  #                     },
  #                     body=json.dumps(data).encode('utf-8')
  #                 )
                  
  #                 responseData = {}
  #                 responseData['message'] = "Venafi application successfully deleted"
  #                 responseData['application_name'] = application_name
  #                 responseData['app_guid'] = app_guid
  #                 cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
  #             else:
  #                 logging.error('Unknown operation: %s', event.get('RequestType'))

  # VenafiCustomResource:
  #   Type: Custom::Venafi
  #   DependsOn: VenafiLambda
  #   Properties:
  #     ServiceToken: !GetAtt VenafiLambda.Arn
  #     TLSPCAPIKey: !Ref TLSPCAPIKey
  #     AppName: !Ref AppName
  #     CAName: !Ref CAName
  #     TemplateName: !Ref TemplateName

Outputs:
  PublicIP:
    Value: !GetAtt AppVM.PublicIp
    Description: Public IP address of the VM

  DomainName:
    Value: !Join ["", [!Ref AppName, ".com"]]
    Description: The URL associated with the certificate

  URL:
    Value: !Join ["", ["https://", !Ref AppName, ".com"]]
    Description: The URL associated with the certificate
